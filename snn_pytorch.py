# -*- coding: utf-8 -*-
"""SNN PyTorch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F5Woz26NmJy5C6ERnTho50fv5zFCZr7G
"""

import torch.nn as nn
import SpykeTorch.snn as snn
import SpykeTorch.functional as sf

class DCSNN(nn.Module):
   def __init__(self):
      super(DCSNN, self).__init__()
      #(in_channels, out_channels, kernel_size, weight_mean=0.8, weight_std=0.02)
      self.conv1 = snn.Convolution(6, 30, 5, 0.8, 0.05)
      self.conv2 = snn.Convolution(30, 250, 3, 0.8, 0.05)
      self.conv3 = snn.Convolution(250, 200, 5, 0.8, 0.05)

      #(conv_layer, learning_rate, use_stabilizer=True, lower_bound=0, upper_bound=1)
      self.stdp1 = snn.STDP(self.conv1, (0.004, -0.003))
      self.stdp2 = snn.STDP(self.conv2, (0.004, -0.003))
      self.stdp3 = snn.STDP(self.conv3, (0.004, -0.003), False, 0.2, 0.8)
      self.anti_stdp3 = snn.STDP(self.conv3, (-0.004, 0.0005), False, 0.2, 0.8)

def forward(self, input):
  input = sf.pad(input, (2,2,2,2))
  if not self.training:
    pot = self.conv1(input)
    spk = sf.fire(pot, 15)
    pot = self.conv2(sf.pad(sf.pooling(spk, 2, 2), (1,1,1,1)))
    spk = sf.fire(pot, 10)
    pot = self.conv3(sf.pad(sf.pooling(spk, 3, 3), (2,2,2,2)))
    # omitting the threshold parameters means infinite threshold
    spk = sf.fire_(pot)
    winners = sf.get_k_winners(pot, 1)
    output = -1
    # each winner is a tuple of form (feature, row, column)
    if len(winners) != 0:
      output = self.decision_map[winners[0][0]]
      return output

def save_data(self, input_spk, pot, spk, winners):
  self.ctx["input_spikes"] = input_spk
  self.ctx["potentials"] = pot
  self.ctx["output_spikes"] = spk
  self.ctx["winners"] = winners

def forward(self, input, max_layer):
  input = sf.pad(input, (2,2,2,2))
  if self.training: 
    #forward pass for train
    pot = self.conv1(input)
    spk, pot = sf.fire(pot, 15, True)
    if max_layer == 1:
      winners = sf.get_k_winners(pot, 5, 3)
      self.save_data(input, pot, spk, winners)
      return spk, pot
    spk_in = sf.pad(sf.pooling(spk, 2, 2), (1,1,1,1))
    pot = self.conv2(spk_in)
    spk, pot = sf.fire(pot, 10, True)
    if max_layer == 2:
      winners = sf.get_k_winners(pot, 8, 2)
      self.save_data(spk_in, pot, spk, winners)
      return spk, pot
    spk_in = sf.pad(sf.pooling(spk, 3, 3), (2,2,2,2))
    pot = self.conv3(spk_in)
    spk = sf.fire_(pot)
    winners = sf.get_k_winners(pot, 1)
    self.save_data(spk_in, pot, spk, winners)
    output = -1
    if len(winners) != 0:
      output = self.decision_map[winners[0][0]]
    return output
  else:
    # forward pass for testing process